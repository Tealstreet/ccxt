<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use React\Async;

class kucoinfutures extends \ccxt\async\kucoin {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchMyTrades' => true,
                'watchTicker' => true,
                'watchTrades' => true,
                'watchBalance' => false, // on backend
            ),
            'options' => array(
                'channelPrefix' => 'contractMarket',
                'watchTicker' => array(
                    'topic' => 'contractMarket/tickerV2',
                ),
                'watchTrades' => array(
                    'topic' => 'contractMarket/execution',
                ),
                'watchOrderBook' => array(
                    'topic' => 'contractMarket/level2',
                ),
            ),
        ));
    }

    public function negotiate($params = array ()) {
        return Async\async(function () use ($params) {
            $client = $this->client('ws');
            $messageHash = 'negotiate';
            $future = $this->safe_value($client->subscriptions, $messageHash);
            if ($future === null) {
                $future = $client->future ($messageHash);
                $client->subscriptions[$messageHash] = $future;
                $response = null;
                $throwException = false;
                if ($this->check_required_credentials($throwException)) {
                    $response = Async\await($this->futuresPrivatePostBulletPrivate ());
                    //
                    //     {
                    //         code => "200000",
                    //         $data => {
                    //             $instanceServers => array(
                    //                 {
                    //                     pingInterval =>  50000,
                    //                     $endpoint => "wss://push-private.kucoin.com/endpoint",
                    //                     protocol => "websocket",
                    //                     encrypt => true,
                    //                     pingTimeout => 10000
                    //                 }
                    //             ),
                    //             $token => "2neAiuYvAU61ZDXANAGAsiL4-iAExhsBXZxftpOeh_55i3Ysy2q2LEsEWU64mdzUOPusi34M_wGoSf7iNyEWJ1UQy47YbpY4zVdzilNP-Bj3iXzrjjGlWtiYB9J6i9GjsxUuhPw3BlrzazF6ghq4Lzf7scStOz3KkxjwpsOBCH4=.WNQmhZQeUKIkh97KYgU0Lg=="
                    //         }
                    //     }
                    //
                } else {
                    $response = Async\await($this->futuresPublicPostBulletPublic ());
                }
                $client->resolve ($response, $messageHash);
                // $data = $this->safe_value($response, 'data', array());
                // $instanceServers = $this->safe_value($data, 'instanceServers', array());
                // $firstServer = $this->safe_value($instanceServers, 0, array());
                // $endpoint = $this->safe_string($firstServer, 'endpoint');
                // $token = $this->safe_string($data, 'token');
            }
            return Async\await($future);
        }) ();
    }

    public function handle_order_book($client, $message) {
        // {
        //     "sequence" => 1668015155477,
        //   "change" => "0.514,buy,64874",
        //   "timestamp" => 1668480414142
        // }
        $messageHash = $this->safe_string($message, 'topic');
        $marketId = explode(':', $messageHash)[1];
        $symbol = $this->safe_symbol($marketId, null, '-');
        $orderbook = $this->orderbooks[$symbol];
        if ($orderbook['nonce'] === null) {
            $subscription = $this->safe_value($client->subscriptions, $messageHash);
            $fetchingOrderBookSnapshot = $this->safe_value($subscription, 'fetchingOrderBookSnapshot');
            if ($fetchingOrderBookSnapshot === null) {
                $subscription['fetchingOrderBookSnapshot'] = true;
                $client->subscriptions[$messageHash] = $subscription;
                $options = $this->safe_value($this->options, 'fetchOrderBookSnapshot', array());
                $delay = $this->safe_integer($options, 'delay', $this->rateLimit);
                // fetch the snapshot in a separate async call after a warmup $delay
                $this->delay($delay, $this->fetchOrderBookSnapshot, $client, $message, $subscription);
            }
            // 1. After receiving the websocket Level 2 data flow, cache the data.
            $orderbook->cache[] = $message;
        } else {
            $this->handle_order_book_message($client, $message, $orderbook);
            $client->resolve ($orderbook, $messageHash);
        }
    }

    public function handle_order_book_message($client, $message, $orderbook) {
        // {
        //   "sequence" => 1668015155477,
        //   "change" => "0.514,buy,64874",
        //   "timestamp" => 1668480414142
        // }
        $data = $this->safe_value($message, 'data', array());
        $sequence = $this->safe_integer($data, 'sequence');
        // 4. Apply the new Level 2 $data flow to the local snapshot to ensure that
        // the $sequence of the new Level 2 update lines up with the $sequence of
        // the previous Level 2 $data-> Discard all the $message prior to that
        // $sequence, and then playback the $change to snapshot.
        if ($sequence > $orderbook['nonce']) {
            $changeStr = $this->safe_value($data, 'change');
            $changeArr = explode(',', $changeStr);
            $side = $changeArr[1];
            $change = [ $changeArr[0], $changeArr[2], $sequence ];
            // 5. Update the level2 full $data based on $sequence according to the
            // size. If the price is 0, ignore the messages and update the $sequence->
            // If the size=0, update the $sequence and remove the price of which the
            // size is 0 out of level 2. For other cases, please update the price.
            if ($side === 'buy') {
                $this->handleDeltas ($orderbook['bids'], array( $change ), $orderbook['nonce']);
            } else {
                $this->handleDeltas ($orderbook['asks'], array( $change ), $orderbook['nonce']);
            }
            $orderbook['nonce'] = $sequence;
            $orderbook['timestamp'] = null;
            $orderbook['datetime'] = null;
        }
        return $orderbook;
    }

    public function handle_subject($client, $message) {
        $subject = $this->safe_string($message, 'subject');
        $methods = array(
            'level2' => array($this, 'handle_order_book'),
            'tickerV2' => $this->handleTicker,
            'match' => $this->handleTrade,
            'trade.candles.update' => $this->handleOHLCV,
        );
        $method = $this->safe_value($methods, $subject);
        if ($subject === 'orderChange') {
            $data = $this->safe_value($message, 'data');
            $type = $this->safe_string($data, 'type');
            if ($type === 'match') {
                $method = $this->handleMyTrade;
            } else {
                $method = $this->handleOrder;
            }
        }
        if ($method === null) {
            return $message;
        } else {
            return $method($client, $message);
        }
    }

    public function handle_error_message($client, $message) {
        return $message;
    }

    public function handle_message($client, $message) {
        // var_dump($message);
        if ($this->handle_error_message($client, $message)) {
            $type = $this->safe_string($message, 'type');
            $methods = array(
                // 'heartbeat' => $this->handleHeartbeat,
                'welcome' => $this->handleSystemStatus,
                'ack' => $this->handleSubscriptionStatus,
                'message' => array($this, 'handle_subject'),
                'pong' => $this->handlePong,
            );
            $method = $this->safe_value($methods, $type);
            if ($method === null) {
                return $message;
            } else {
                return $method($client, $message);
            }
        }
    }
}
