<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\InvalidNonce;
use ccxt\AuthenticationError;
use React\Async;

class blofin extends \ccxt\async\blofin {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchBalance' => false,
                'watchMyTrades' => false,
                'watchOHLCV' => true,
                'watchOrderBook' => true,
                'watchOrders' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://openapi.blofin.com/ws/public',
                        'private' => 'wss://openapi.blofin.com/ws/private',
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'public' => 'wss://openapi.blofin.com/ws/public',
                        'private' => 'wss://openapi.blofin.com/ws/private',
                    ),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
                'uid' => true,
            ),
            'options' => array(
                'tradesLimit' => 1000,
                'ordersLimit' => 1000,
                'requestId' => array(),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 10000,
            ),
        ));
    }

    public function request_id($url) {
        $options = $this->safe_value($this->options, 'requestId', array());
        $previousValue = $this->safe_integer($options, $url, 0);
        $newValue = $this->sum($previousValue, 1);
        $this->options['requestId'][$url] = $newValue;
        return $newValue;
    }

    public function subscribe($access, $channel, $symbol, $params = array ()) {
        return Async\async(function () use ($access, $channel, $symbol, $params) {
            Async\await($this->load_markets());
            $url = $this->urls['api']['ws'][$access];
            $messageHash = $channel;
            $firstArgument = array(
                'channel' => $channel,
            );
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $messageHash .= ':' . $market['id'];
                $firstArgument['instId'] = $market['id'];
            }
            $request = array(
                'op' => 'subscribe',
                'args' => array(
                    $this->deep_extend($firstArgument, $params),
                ),
            );
            return Async\await($this->watch($url, $messageHash, $request, $messageHash));
        }) ();
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $symbol = $this->symbol($symbol);
            $trades = Async\await($this->subscribe('public', 'trades', $symbol, $params));
            if ($this->newUpdates) {
                $limit = $trades->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($trades, $since, $limit, 'timestamp', true);
        }) ();
    }

    public function handle_trades($client, $message) {
        $arg = $this->safe_value($message, 'arg', array());
        $channel = $this->safe_string($arg, 'channel');
        $data = $this->safe_value($message, 'data', array());
        $tradesLimit = $this->safe_integer($this->options, 'tradesLimit', 1000);
        for ($i = 0; $i < count($data); $i++) {
            $trade = $this->parse_trade($data[$i]);
            $symbol = $trade['symbol'];
            $marketId = $this->safe_string($trade['info'], 'instId');
            $messageHash = $channel . ':' . $marketId;
            $stored = $this->safe_value($this->trades, $symbol);
            if ($stored === null) {
                $stored = new ArrayCache ($tradesLimit);
                $this->trades[$symbol] = $stored;
            }
            $stored->append ($trade);
            $client->resolve ($stored, $messageHash);
        }
        return $message;
    }

    public function watch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
             * @param {string} $symbol unified $symbol of the market to fetch the ticker for
             * @param {array} $params extra parameters specific to the okx api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/#/?id=ticker-structure ticker structure~
             */
            return Async\await($this->subscribe('public', 'tickers', $symbol, $params));
        }) ();
    }

    public function handle_ticker($client, $message) {
        $arg = $this->safe_value($message, 'arg', array());
        $channel = $this->safe_string($arg, 'channel');
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $ticker = $this->parse_ticker($data[$i]);
            $symbol = $ticker['symbol'];
            $marketId = $this->safe_string($ticker['info'], 'instId');
            $messageHash = $channel . ':' . $marketId;
            $this->tickers[$symbol] = $ticker;
            $client->resolve ($ticker, $messageHash);
        }
        return $message;
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $symbol = $this->symbol($symbol);
            $interval = $this->safe_string($this->timeframes, $timeframe, $timeframe);
            $name = 'candle' . $interval;
            $ohlcv = Async\await($this->subscribe('public', $name, $symbol, $params));
            if ($this->newUpdates) {
                $limit = $ohlcv->getLimit ($symbol, $limit);
            }
            return $this->filter_by_since_limit($ohlcv, $since, $limit, 0, true);
        }) ();
    }

    public function handle_ohlcv($client, $message) {
        $arg = $this->safe_value($message, 'arg', array());
        $channel = $this->safe_string($arg, 'channel');
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($arg, 'instId');
        $market = $this->safe_market($marketId);
        $symbol = $market['id'];
        $interval = str_replace('candle', '', $channel);
        // use a reverse lookup in a static map instead
        $timeframe = $this->find_timeframe($interval);
        for ($i = 0; $i < count($data); $i++) {
            $parsed = $this->parse_ohlcv($data[$i], $market);
            $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
            $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
            if ($stored === null) {
                $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                $stored = new ArrayCacheByTimestamp ($limit);
                $this->ohlcvs[$symbol][$timeframe] = $stored;
            }
            $stored->append ($parsed);
            $messageHash = $channel . ':' . $marketId;
            $client->resolve ($stored, $messageHash);
        }
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the market to fetch the order book for
             * @param {int|null} $limit the maximum amount of order book entries to return
             * @param {array} $params extra parameters specific to the okx api endpoint
             * @return {array} A dictionary of ~@link https://docs.ccxt.com/#/?id=order-book-structure order book structures~ indexed by market symbols
             */
            $options = $this->safe_value($this->options, 'watchOrderBook', array());
            //
            // bbo-tbt
            // 1. Newly added channel that sends tick-by-tick Level 1 data
            // 2. All API users can subscribe
            // 3. Public $depth channel, verification not required
            //
            // books-l2-tbt
            // 1. Only users who're VIP5 and above can subscribe
            // 2. Identity verification required before subscription
            //
            // books50-l2-tbt
            // 1. Only users who're VIP4 and above can subscribe
            // 2. Identity verification required before subscription
            //
            // books
            // 1. All API users can subscribe
            // 2. Public $depth channel, verification not required
            //
            // books5
            // 1. All API users can subscribe
            // 2. Public $depth channel, verification not required
            // 3. Data feeds will be delivered every 100ms (vs. every 200ms now)
            //
            $depth = $this->safe_string($options, 'depth', 'books');
            if (($depth === 'books-l2-tbt') || ($depth === 'books50-l2-tbt')) {
                Async\await($this->authenticate(array( 'access' => 'public' )));
            }
            $orderbook = Async\await($this->subscribe('public', $depth, $symbol, $params));
            return $orderbook->limit ();
        }) ();
    }

    public function handle_delta($bookside, $delta) {
        $price = $this->safe_float($delta, 0);
        $amount = $this->safe_float($delta, 1);
        $bookside->store ($price, $amount);
    }

    public function handle_deltas($bookside, $deltas) {
        for ($i = 0; $i < count($deltas); $i++) {
            $this->handle_delta($bookside, $deltas[$i]);
        }
    }

    public function handle_order_book_message($client, $message, $orderbook, $messageHash) {
        $asks = $this->safe_value($message, 'asks', array());
        $bids = $this->safe_value($message, 'bids', array());
        $storedAsks = $orderbook['asks'];
        $storedBids = $orderbook['bids'];
        $this->handle_deltas($storedAsks, $asks);
        $this->handle_deltas($storedBids, $bids);
        $checksum = $this->safe_value($this->options, 'checksum', true);
        if ($checksum) {
            $asksLength = count($storedAsks);
            $bidsLength = count($storedBids);
            $payloadArray = array();
            for ($i = 0; $i < 25; $i++) {
                if ($i < $bidsLength) {
                    $payloadArray[] = $this->number_to_string($storedBids[$i][0]);
                    $payloadArray[] = $this->number_to_string($storedBids[$i][1]);
                }
                if ($i < $asksLength) {
                    $payloadArray[] = $this->number_to_string($storedAsks[$i][0]);
                    $payloadArray[] = $this->number_to_string($storedAsks[$i][1]);
                }
            }
            $payload = implode(':', $payloadArray);
            $responseChecksum = $this->safe_integer($message, 'checksum');
            $localChecksum = $this->crc32($payload, true);
            if ($responseChecksum !== $localChecksum) {
                $error = new InvalidNonce ($this->id . ' invalid checksum');
                $client->reject ($error, $messageHash);
            }
        }
        $timestamp = $this->safe_integer($message, 'ts');
        $orderbook['timestamp'] = $timestamp;
        $orderbook['datetime'] = $this->iso8601($timestamp);
        return $orderbook;
    }

    public function handle_order_book($client, $message) {
        $arg = $this->safe_value($message, 'arg', array());
        $channel = $this->safe_string($arg, 'channel');
        $action = $this->safe_string($message, 'action');
        $data = $this->safe_value($message, 'data', array());
        $marketId = $this->safe_string($arg, 'instId');
        $market = $this->safe_market($marketId);
        $symbol = $market['symbol'];
        $depths = array(
            'bbo-tbt' => 1,
            'books' => 400,
            'books5' => 5,
            'books-l2-tbt' => 400,
            'books50-l2-tbt' => 50,
        );
        $limit = $this->safe_integer($depths, $channel);
        $messageHash = $channel . ':' . $marketId;
        if ($action === 'snapshot') {
            for ($i = 0; $i < count($data); $i++) {
                $update = $data[$i];
                $orderbook = $this->order_book(array(), $limit);
                $this->orderbooks[$symbol] = $orderbook;
                $orderbook['symbol'] = $symbol;
                $this->handle_order_book_message($client, $update, $orderbook, $messageHash);
                $client->resolve ($orderbook, $messageHash);
            }
        } elseif ($action === 'update') {
            if (is_array($this->orderbooks) && array_key_exists($symbol, $this->orderbooks)) {
                $orderbook = $this->orderbooks[$symbol];
                for ($i = 0; $i < count($data); $i++) {
                    $update = $data[$i];
                    $this->handle_order_book_message($client, $update, $orderbook, $messageHash);
                    $client->resolve ($orderbook, $messageHash);
                }
            }
        } elseif (($channel === 'books5') || ($channel === 'bbo-tbt')) {
            $orderbook = $this->safe_value($this->orderbooks, $symbol);
            if ($orderbook === null) {
                $orderbook = $this->order_book(array(), $limit);
            }
            $this->orderbooks[$symbol] = $orderbook;
            for ($i = 0; $i < count($data); $i++) {
                $update = $data[$i];
                $timestamp = $this->safe_integer($update, 'ts');
                $snapshot = $this->parse_order_book($update, $symbol, $timestamp, 'bids', 'asks', 0, 1);
                $orderbook->reset ($snapshot);
                $client->resolve ($orderbook, $messageHash);
            }
        }
        return $message;
    }

    public function check_required_uid() {
        // checkRequiredUid (error = true) {
        return true;
        // if (!$this->uid) {
        //     if (error) {
        //         throw new AuthenticationError($this->id . ' requires `uid` credential');
        //     } else {
        //         return false;
        //     }
        // }
        // return true;
    }

    public function authenticate($params = array ()) {
        $this->check_required_credentials();
        $url = $this->urls['api']['ws']['private'] . '/' . $this->uid;
        $client = $this->client($url);
        $messageHash = 'authenticated';
        $event = 'auth';
        $future = $this->safe_value($client->subscriptions, $messageHash);
        if ($future === null) {
            $ts = (string) $this->nonce();
            $auth = '|' . $ts;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
            $request = array(
                'event' => $event,
                'params' => array(
                    'apikey' => $this->apiKey,
                    'sign' => $signature,
                    'timestamp' => $ts,
                ),
            );
            $message = array_merge($request, $params);
            $future = $this->watch($url, $messageHash, $message);
            $client->subscriptions[$messageHash] = $future;
        }
        return $future;
    }

    public function watch_private($messageHash, $message, $params = array ()) {
        return Async\async(function () use ($messageHash, $message, $params) {
            Async\await($this->authenticate($params));
            $url = $this->urls['api']['ws']['private'] . '/' . $this->uid;
            $requestId = $this->request_id($url);
            $subscribe = array(
                'id' => $requestId,
            );
            $request = array_merge($subscribe, $message);
            return Async\await($this->watch($url, $messageHash, $request, $messageHash, $subscribe));
        }) ();
    }

    public function watch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $topic = 'executionreport';
            $messageHash = $topic;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $symbol = $market['symbol'];
                $messageHash .= ':' . $symbol;
            }
            $request = array(
                'event' => 'subscribe',
                'topic' => $topic,
            );
            $message = array_merge($request, $params);
            $orders = Async\await($this->watch_private($messageHash, $message));
            if ($this->newUpdates) {
                $limit = $orders->getLimit ($symbol, $limit);
            }
            return $this->filter_by_symbol_since_limit($orders, $symbol, $since, $limit, true);
        }) ();
    }

    public function parse_ws_order($order, $market = null) {
        return $this->parse_order($order, $market);
    }

    public function handle_order_update($client, $message) {
        //
        //     {
        //         topic => 'executionreport',
        //         ts => 1657515556799,
        //         data => {
        //             symbol => 'PERP_BTC_USDT',
        //             clientOrderId => 0,
        //             orderId => 52952826,
        //             type => 'LIMIT',
        //             side => 'SELL',
        //             quantity => 0.01,
        //             price => 22000,
        //             tradeId => 0,
        //             executedPrice => 0,
        //             executedQuantity => 0,
        //             fee => 0,
        //             feeAsset => 'USDT',
        //             totalExecutedQuantity => 0,
        //             status => 'NEW',
        //             reason => '',
        //             orderTag => 'default',
        //             totalFee => 0,
        //             visible => 0.01,
        //             timestamp => 1657515556799,
        //             reduceOnly => false,
        //             maker => false
        //         }
        //     }
        //
        $order = $this->safe_value($message, 'data');
        $this->handle_order($client, $order);
    }

    public function handle_order($client, $message) {
        $topic = 'executionreport';
        $parsed = $this->parse_ws_order($message);
        $symbol = $this->safe_string($parsed, 'symbol');
        $orderId = $this->safe_string($parsed, 'id');
        if ($symbol !== null) {
            if ($this->orders === null) {
                $limit = $this->safe_integer($this->options, 'ordersLimit', 1000);
                $this->orders = new ArrayCacheBySymbolById ($limit);
            }
            $cachedOrders = $this->orders;
            $orders = $this->safe_value($cachedOrders->hashmap, $symbol, array());
            $order = $this->safe_value($orders, $orderId);
            if ($order !== null) {
                $fee = $this->safe_value($order, 'fee');
                if ($fee !== null) {
                    $parsed['fee'] = $fee;
                }
                $fees = $this->safe_value($order, 'fees');
                if ($fees !== null) {
                    $parsed['fees'] = $fees;
                }
                $parsed['trades'] = $this->safe_value($order, 'trades');
                $parsed['timestamp'] = $this->safe_integer($order, 'timestamp');
                $parsed['datetime'] = $this->safe_string($order, 'datetime');
            }
            $cachedOrders->append ($parsed);
            $client->resolve ($this->orders, $topic);
            $messageHashSymbol = $topic . ':' . $symbol;
            $client->resolve ($this->orders, $messageHashSymbol);
        }
    }

    public function handle_message($client, $message) {
        if (!$this->handle_error_message($client, $message)) {
            return;
        }
        //
        //     array( event => 'subscribe', $arg => array( $channel => 'tickers', instId => 'BTC-USDT' ) )
        //     array( event => 'login', msg => '', code => '0' )
        //
        //     {
        //         $arg => array( $channel => 'tickers', instId => 'BTC-USDT' ),
        //         data => array(
        //             {
        //                 instType => 'SPOT',
        //                 instId => 'BTC-USDT',
        //                 last => '31500.1',
        //                 lastSz => '0.00001754',
        //                 askPx => '31500.1',
        //                 askSz => '0.00998144',
        //                 bidPx => '31500',
        //                 bidSz => '3.05652439',
        //                 open24h => '31697',
        //                 high24h => '32248',
        //                 low24h => '31165.6',
        //                 sodUtc0 => '31385.5',
        //                 sodUtc8 => '32134.9',
        //                 volCcy24h => '503403597.38138519',
        //                 vol24h => '15937.10781721',
        //                 ts => '1626526618762'
        //             }
        //         )
        //     }
        //
        //     array( event => 'error', msg => 'Illegal request => array("op":"subscribe","args":["spot/ticker:BTC-USDT"])', code => '60012' )
        //     array( event => 'error', msg => "channel:ticker,instId:BTC-USDT doesn't exist", code => '60018' )
        //     array( event => 'error', msg => 'Invalid OK_ACCESS_KEY', code => '60005' )
        //     {
        //         event => 'error',
        //         msg => 'Illegal request => array("op":"login","args":["de89b035-b233-44b2-9a13-0ccdd00bda0e","7KUcc8YzQhnxBE3K","1626691289","H57N99mBt5NvW8U19FITrPdOxycAERFMaapQWRqLaSE="])',
        //         code => '60012'
        //     }
        //
        //
        //
        if ($message === 'pong') {
            return $this->handle_pong($client, $message);
        }
        // $table = $this->safe_string($message, 'table');
        // if ($table === null) {
        $arg = $this->safe_value($message, 'arg', array());
        var_dump($message);
        $channel = $this->safe_string($arg, 'channel');
        $methods = array(
            'bbo-tbt' => array($this, 'handle_order_book'), // newly added $channel that sends tick-by-tick Level 1 data, all API users can subscribe, public depth $channel, verification not required
            'books' => array($this, 'handle_order_book'), // all API users can subscribe, public depth $channel, verification not required
            'books5' => array($this, 'handle_order_book'), // all API users can subscribe, public depth $channel, verification not required, data feeds will be delivered every 100ms (vs. every 200ms now)
            'books50-l2-tbt' => array($this, 'handle_order_book'), // only users who're VIP4 and above can subscribe, identity verification required before subscription
            'books-l2-tbt' => array($this, 'handle_order_book'), // only users who're VIP5 and above can subscribe, identity verification required before subscription
            'tickers' => array($this, 'handle_ticker'),
            'trades' => array($this, 'handle_trades'),
        );
        $method = $this->safe_value($methods, $channel);
        if ($method === null) {
            if (mb_strpos($channel, 'candle') === 0) {
                $this->handle_ohlcv($client, $message);
            } else {
                return $message;
            }
        } else {
            return $method($client, $message);
        }
    }

    public function ping($client) {
        // okex does not support built-in ws protocol-level ping-pong
        // instead it requires custom text-based ping-pong
        return 'ping';
    }

    public function handle_pong($client, $message) {
        $client->lastPong = $this->milliseconds();
        return $message;
    }

    public function handle_error_message($client, $message) {
        //
        //     array( event => 'error', msg => 'Illegal request => array("op":"subscribe","args":["spot/ticker:BTC-USDT"])', code => '60012' )
        //     array( event => 'error', msg => "channel:ticker,instId:BTC-USDT doesn't exist", code => '60018' )
        //
        $errorCode = $this->safe_integer($message, 'code');
        try {
            if ($errorCode) {
                $feedback = $this->id . ' ' . $this->json($message);
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
                $messageString = $this->safe_value_2($message, 'message', 'msg');
                if ($messageString !== null) {
                    $this->throw_broadly_matched_exception($this->exceptions['broad'], $messageString, $feedback);
                }
            }
        } catch (Exception $e) {
            if ($e instanceof AuthenticationError) {
                $messageHash = 'authenticated';
                $client->reject ($e, $messageHash);
                if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                    unset($client->subscriptions[$messageHash]);
                }
                return false;
            }
        }
        return $message;
    }

    public function handle_subscribe($client, $message) {
        //
        //     {
        //         id => '666888',
        //         event => 'subscribe',
        //         success => true,
        //         ts => 1657117712212
        //     }
        //
        return $message;
    }

    public function handle_auth($client, $message) {
        //
        //     {
        //         event => 'auth',
        //         $success => true,
        //         ts => 1657463158812
        //     }
        //
        $messageHash = 'authenticated';
        $success = $this->safe_value($message, 'success');
        if ($success) {
            $client->resolve ($message, $messageHash);
        } else {
            $error = new AuthenticationError ($this->json($message));
            $client->reject ($error, $messageHash);
            // allows further authentication attempts
            if (is_array($client->subscriptions) && array_key_exists($messageHash, $client->subscriptions)) {
                unset($client->subscriptions['authenticated']);
            }
        }
    }
}
