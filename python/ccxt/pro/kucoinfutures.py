# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.pro.kucoin import kucoin


class kucoinfutures(kucoin):

    def describe(self):
        return self.deep_extend(super(kucoinfutures, self).describe(), {
            'has': {
                'ws': True,
                'watchOrderBook': True,
                'watchMyTrades': True,
                'watchTicker': True,
                'watchTrades': True,
                'watchBalance': False,  # on backend
            },
            'options': {
                'channelPrefix': 'contractMarket',
                'watchTicker': {
                    'topic': 'contractMarket/tickerV2',
                },
                'watchTrades': {
                    'topic': 'contractMarket/execution',
                },
                'watchOrderBook': {
                    'topic': 'contractMarket/level2',
                },
            },
        })

    async def negotiate(self, params={}):
        client = self.client('ws')
        messageHash = 'negotiate'
        future = self.safe_value(client.subscriptions, messageHash)
        if future is None:
            future = client.future(messageHash)
            client.subscriptions[messageHash] = future
            response = None
            throwException = False
            if self.check_required_credentials(throwException):
                response = await self.futuresPrivatePostBulletPrivate()
                #
                #     {
                #         code: "200000",
                #         data: {
                #             instanceServers: [
                #                 {
                #                     pingInterval:  50000,
                #                     endpoint: "wss://push-private.kucoin.com/endpoint",
                #                     protocol: "websocket",
                #                     encrypt: True,
                #                     pingTimeout: 10000
                #                 }
                #             ],
                #             token: "2neAiuYvAU61ZDXANAGAsiL4-iAExhsBXZxftpOeh_55i3Ysy2q2LEsEWU64mdzUOPusi34M_wGoSf7iNyEWJ1UQy47YbpY4zVdzilNP-Bj3iXzrjjGlWtiYB9J6i9GjsxUuhPw3BlrzazF6ghq4Lzf7scStOz3KkxjwpsOBCH4=.WNQmhZQeUKIkh97KYgU0Lg=="
                #         }
                #     }
                #
            else:
                response = await self.futuresPublicPostBulletPublic()
            client.resolve(response, messageHash)
            # data = self.safe_value(response, 'data', {})
            # instanceServers = self.safe_value(data, 'instanceServers', [])
            # firstServer = self.safe_value(instanceServers, 0, {})
            # endpoint = self.safe_string(firstServer, 'endpoint')
            # token = self.safe_string(data, 'token')
        return await future

    def handle_order_book(self, client, message):
        # {
        #     "sequence": 1668015155477,
        #   "change": "0.514,buy,64874",
        #   "timestamp": 1668480414142
        # }
        messageHash = self.safe_string(message, 'topic')
        marketId = messageHash.split(':')[1]
        symbol = self.safe_symbol(marketId, None, '-')
        orderbook = self.orderbooks[symbol]
        if orderbook['nonce'] is None:
            subscription = self.safe_value(client.subscriptions, messageHash)
            fetchingOrderBookSnapshot = self.safe_value(subscription, 'fetchingOrderBookSnapshot')
            if fetchingOrderBookSnapshot is None:
                subscription['fetchingOrderBookSnapshot'] = True
                client.subscriptions[messageHash] = subscription
                options = self.safe_value(self.options, 'fetchOrderBookSnapshot', {})
                delay = self.safe_integer(options, 'delay', self.rateLimit)
                # fetch the snapshot in a separate async call after a warmup delay
                self.delay(delay, self.fetchOrderBookSnapshot, client, message, subscription)
            # 1. After receiving the websocket Level 2 data flow, cache the data.
            orderbook.cache.append(message)
        else:
            self.handle_order_book_message(client, message, orderbook)
            client.resolve(orderbook, messageHash)

    def handle_order_book_message(self, client, message, orderbook):
        # {
        #   "sequence": 1668015155477,
        #   "change": "0.514,buy,64874",
        #   "timestamp": 1668480414142
        # }
        data = self.safe_value(message, 'data', {})
        sequence = self.safe_integer(data, 'sequence')
        # 4. Apply the new Level 2 data flow to the local snapshot to ensure that
        # the sequence of the new Level 2 update lines up with the sequence of
        # the previous Level 2 data. Discard all the message prior to that
        # sequence, and then playback the change to snapshot.
        if sequence > orderbook['nonce']:
            changeStr = self.safe_value(data, 'change')
            changeArr = changeStr.split(',')
            side = changeArr[1]
            change = [changeArr[0], changeArr[2], sequence]
            # 5. Update the level2 full data based on sequence according to the
            # size. If the price is 0, ignore the messages and update the sequence.
            # If the size=0, update the sequence and remove the price of which the
            # size is 0 out of level 2. For other cases, please update the price.
            if side == 'buy':
                self.handleDeltas(orderbook['bids'], [change], orderbook['nonce'])
            else:
                self.handleDeltas(orderbook['asks'], [change], orderbook['nonce'])
            orderbook['nonce'] = sequence
            orderbook['timestamp'] = None
            orderbook['datetime'] = None
        return orderbook

    def handle_subject(self, client, message):
        subject = self.safe_string(message, 'subject')
        methods = {
            'level2': self.handle_order_book,
            'tickerV2': self.handleTicker,
            'match': self.handleTrade,
            'trade.candles.update': self.handleOHLCV,
        }
        method = self.safe_value(methods, subject)
        if subject == 'orderChange':
            data = self.safe_value(message, 'data')
            type = self.safe_string(data, 'type')
            if type == 'match':
                method = self.handleMyTrade
            else:
                method = self.handleOrder
        if method is None:
            return message
        else:
            return method(client, message)

    def handle_error_message(self, client, message):
        return message

    def handle_message(self, client, message):
        # console.log(message)
        if self.handle_error_message(client, message):
            type = self.safe_string(message, 'type')
            methods = {
                # 'heartbeat': self.handleHeartbeat,
                'welcome': self.handleSystemStatus,
                'ack': self.handleSubscriptionStatus,
                'message': self.handle_subject,
                'pong': self.handlePong,
            }
            method = self.safe_value(methods, type)
            if method is None:
                return message
            else:
                return method(client, message)
