# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NotSupported
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import AuthenticationError
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class blofin(Exchange):

    def describe(self):
        return self.deep_extend(super(blofin, self).describe(), {
            'id': 'blofin',
            'name': 'Blofin',
            'countries': ['KY'],  # Cayman Islands
            'rateLimit': 100,
            'version': 'v1',
            'certified': False,
            'pro': True,
            'hostname': 'blofin.com',
            'has': {
                'CORS': None,
                'spot': False,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'addMargin': False,
                'borrowMargin': False,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'cancelWithdraw': False,  # exchange have that endpoint disabled atm, but was once implemented in ccxt per old docs: https://kronosresearch.github.io/wootrade-documents/#cancel-withdraw-request
                'createDepositAddress': False,
                'createMarketOrder': False,
                'createOrder': True,
                'createReduceOnlyOrder': True,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'fetchAccounts': True,
                'fetchBalance': True,
                'fetchCanceledOrders': False,
                'fetchClosedOrder': False,
                'fetchClosedOrders': False,
                'fetchCurrencies': True,
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchLedger': True,
                'fetchLeverage': True,
                'fetchMarginMode': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenInterestHistory': False,
                'fetchOpenOrder': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchOrderTrades': True,
                'fetchPosition': False,
                'fetchPositionMode': False,
                'fetchPositions': True,
                'fetchPremiumIndexOHLCV': False,
                'fetchStatus': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': False,
                'fetchTrades': True,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTransactions': False,
                'fetchTransfers': False,
                'fetchWithdrawals': False,
                'reduceMargin': False,
                'repayMargin': False,
                'setLeverage': True,
                'setMargin': False,
                'setMarginMode': True,
                'transfer': False,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1H',
                '2h': '2H',
                '4h': '4H',
                '6h': '6H',
                '12h': '12H',
                '1d': '1D',
                '1w': '1W',
                '1M': '1M',
                '3M': '3M',
                '6M': '6M',
                '1y': '1Y',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg',
                'api': {
                    'rest': 'https://openapi.blofin.com',
                },
                'www': 'https://blofin.com/',
                'doc': [
                    'https://docs.blofin.com/',
                ],
            },
            'api': {
                'v1': {
                    'public': {
                        'get': {
                            'market/instruments': 1,
                            'market/tickers': 1,
                            'market/candles': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'account/leverage-info': 1,
                            'asset/balances': 1,
                            'account/positions': 1,
                            'trade/orders-pending': 1,
                            'trade/orders-tpsl-pending': 1,
                        },
                        'post': {
                            'trade/cancel-order': 5,  # 2 requests per 1 second per symbol
                            'trade/cancel-tpsl': 5,  # 2 requests per 1 second per symbol
                            'trade/cancel-batch-orders': 5,  # 2 requests per 1 second per symbol
                            'trade/close-positions': 5,  # 2 requests per 1 second per symbol
                            'trade/order': 5,  # 2 requests per 1 second per symbol
                            'trade/order-tpsl': 5,  # 2 requests per 1 second per symbol
                            'trade/batch-orders': 5,  # 2 requests per 1 second per symbol
                            'client/account_mode': 120,
                            'account/set-leverage': 120,
                        },
                    },
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'percentage': True,
                    'maker': self.parse_number('0.0002'),
                    'taker': self.parse_number('0.0005'),
                },
            },
            'options': {
                'createMarketBuyOrderRequiresPrice': True,
                # these network aliases require manual mapping here
                'network-aliases-for-tokens': {
                    'HT': 'ERC20',
                    'OMG': 'ERC20',
                    'UATOM': 'ATOM',
                    'ZRX': 'ZRX',
                },
                'networks': {
                    'TRX': 'TRON',
                    'TRC20': 'TRON',
                    'ERC20': 'ETH',
                    'BEP20': 'BSC',
                },
                # override defaultNetworkCodePriorities for a specific currency
                'defaultNetworkCodeForCurrencies': {
                    # 'USDT': 'TRC20',
                    # 'BTC': 'BTC',
                },
                'transfer': {
                    'fillResponseFromRequest': True,
                },
                'brokerId': 'ab82cb09-cfec-4473-80a3-b740779d0644',
            },
            'commonCurrencies': {},
            'exceptions': {
                'exact': {
                    '-1000': ExchangeError,  # {"code": -1000,  "message": "An unknown error occurred while processing the request"}
                    '-1001': AuthenticationError,  # {"code": -1001,  "message": "The api key or secret is in wrong format"}
                    '-1002': AuthenticationError,  # {"code": -1002,  "message": "API key or secret is invalid, it may because key have insufficient permission or the key is expired/revoked."}
                    '-1003': RateLimitExceeded,  # {"code": -1003,  "message": "Rate limit exceed."}
                    '-1004': BadRequest,  # {"code": -1004,  "message": "An unknown parameter was sent."}
                    '-1005': BadRequest,  # {"code": -1005,  "message": "Some parameters are in wrong format for api."}
                    '-1006': BadRequest,  # {"code": -1006,  "message": "The data is not found in server."}
                    '-1007': BadRequest,  # {"code": -1007,  "message": "The data is already exists or your request is duplicated."}
                    '-1008': InvalidOrder,  # {"code": -1008,  "message": "The quantity of settlement is too high than you can request."}
                    '-1009': BadRequest,  # {"code": -1009,  "message": "Can not request withdrawal settlement, you need to deposit other arrears first."}
                    '-1011': ExchangeError,  # {"code": -1011,  "message": "Can not place/cancel orders, it may because internal network error. Please try again in a few seconds."}
                    '-1012': BadRequest,  # {"code": -1012,  "message": "Amount is required for buy market orders when margin disabled."}  The place/cancel order request is rejected by internal module, it may because the account is in liquidation or other internal errors. Please try again in a few seconds."}
                    '-1101': InvalidOrder,  # {"code": -1101,  "message": "The risk exposure for client is too high, it may cause by sending too big order or the leverage is too low. please refer to client info to check the current exposure."}
                    '-1102': InvalidOrder,  # {"code": -1102,  "message": "The order value(price * size) is too small."}
                    '-1103': InvalidOrder,  # {"code": -1103,  "message": "The order price is not following the tick size rule for the symbol."}
                    '-1104': InvalidOrder,  # {"code": -1104,  "message": "The order quantity is not following the step size rule for the symbol."}
                    '-1105': InvalidOrder,  # {"code": -1105,  "message": "Price is X% too high or X% too low from the mid price."}
                },
                'broad': {
                    'symbol must not be blank': BadRequest,  # when sending 'cancelOrder' without symbol [-1005]
                    'The token is not supported': BadRequest,  # when getting incorrect token's deposit address [-1005]
                    'Your order and symbol are not valid or already canceled': BadRequest,  # actual response whensending 'cancelOrder' for already canceled id [-1006]
                    'Insufficient WOO. Please enable margin trading for leverage trading': BadRequest,  # when selling insufficent token [-1012]
                },
            },
            'precisionMode': TICK_SIZE,
        })

    async def fetch_markets(self, params={}):
        response = await self.v1PublicGetMarketInstruments(params)
        data = self.safe_value(response, 'data', [])
        return self.parse_markets(data)

    def parse_markets(self, markets):
        result = []
        for i in range(0, len(markets)):
            result.append(self.parse_market(markets[i]))
        return result

    def parse_market(self, market):
        marketId = self.safe_string(market, 'instId')
        parts = marketId.split('-')
        baseId = self.safe_string(parts, 0)
        quoteId = self.safe_string(parts, 1)
        settleId = 'USDT'
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        settle = self.safe_currency_code(settleId)
        # symbol = base + '/' + quote + ':' + settle
        symbol = marketId
        # status = self.safe_number(market, 'status')
        # contractSize = self.safe_number(market, 'size', 1)
        # contractSize = 1
        tickSize = self.safe_string(market, 'tickSize')
        minAmountString = self.safe_string(market, 'minSize')
        minAmount = self.parse_number(minAmountString)
        precisionPrice = self.parse_number(tickSize)
        maxLeverage = self.safe_string(market, 'maxLeverage', '1')
        maxLeverage = Precise.string_max(maxLeverage, '1')
        return {
            'id': marketId,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'settle': settle,
            'baseId': baseId,
            'quoteId': quoteId,
            'settleId': settleId,
            'type': 'swap',
            'spot': False,
            'margin': True,
            'swap': True,
            'future': False,
            'option': False,
            'active': True,
            'contract': True,
            'linear': True,
            'inverse': None,
            'contractSize': self.safe_number(market, 'contractValue'),
            'expiry': None,
            'expiryDatetime': None,
            'strike': None,
            'optionType': None,
            'precision': {
                'amount': self.safe_number(market, 'lotSize'),
                'price': self.parse_number(self.safe_string(market, 'tickSize')),
            },
            'limits': {
                'leverage': {
                    'min': None,
                    'max': self.parse_number(maxLeverage),
                },
                'amount': {
                    'min': minAmount,
                    'max': None,
                },
                'price': {
                    'min': precisionPrice,
                    'max': None,
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            },
            'info': self.deep_extend(market, {'symbol': symbol}),
        }
        # id = self.safe_string(market, 'instId')
        # type = 'future'
        # contract = True
        # baseId = self.safe_string(market, 'baseCurrency')
        # quoteId = self.safe_string(market, 'quoteCurrency')
        # contactType = self.safe_string(market, 'contractType')
        # settleId = self.safe_string_2(market, 'settleCcy', 'quoteCurrency')  # safe to assume that on blofin quote == settle for linear markets -- rayana
        # settle = self.safe_currency_code(settleId)
        # base = self.safe_currency_code(baseId)
        # quote = self.safe_currency_code(quoteId)
        # symbol = base + '/' + quote
        # expiry = None
        # if contract:
        #     symbol = symbol + ':' + settle
        #     expiry = self.safe_integer(market, 'expireTime')
        # }
        # tickSize = self.safe_string(market, 'tickSize')
        # minAmountString = self.safe_string(market, 'minSize')
        # minAmount = self.parse_number(minAmountString)
        # fees = self.safe_value_2(self.fees, type, 'trading', {})
        # precisionPrice = self.parse_number(tickSize)
        # maxLeverage = self.safe_string(market, 'maxLeverage', '1')
        # maxLeverage = Precise.string_max(maxLeverage, '1')
        # return self.extend(fees, {
        #     'id': id,
        #     'symbol': symbol,
        #     'base': base,
        #     'quote': quote,
        #     'settle': settle,
        #     'baseId': baseId,
        #     'quoteId': quoteId,
        #     'settleId': settleId,
        #     'type': type,
        #     'spot': False,
        #     'margin': False,
        #     'swap': False,
        #     'future': True,
        #     'option': False,
        #     'active': True,
        #     'contract': contract,
        #     'linear': contactType == 'linear',
        #     'inverse': contactType == 'inverse',
        #     'contractSize': self.safe_number(market, 'contractValue') if contract else None,
        #     'expiry': expiry,
        #     'expiryDatetime': self.iso8601(expiry),
        #     'strike': None,
        #     'optionType': None,
        #     'precision': {
        #         'amount': self.safe_number(market, 'lotSize'),
        #         'price': precisionPrice,
        #     },
        #     'limits': {
        #         'leverage': {
        #             'min': self.parse_number('1'),
        #             'max': self.parse_number(maxLeverage),
        #         },
        #         'amount': {
        #             'min': minAmount,
        #             'max': None,
        #         },
        #         'price': {
        #             'min': precisionPrice,
        #             'max': None,
        #         },
        #         'cost': {
        #             'min': None,
        #             'max': None,
        #         },
        #     },
        #     'info': market,
        # })

    def parse_ticker(self, ticker, market=None):
        #
        #     {
        #         "instType": "SPOT",
        #         "instId": "ETH-BTC",
        #         "last": "0.07319",
        #         "lastSz": "0.044378",
        #         "askPx": "0.07322",
        #         "askSz": "4.2",
        #         "bidPx": "0.0732",
        #         "bidSz": "6.050058",
        #         "open24h": "0.07801",
        #         "high24h": "0.07975",
        #         "low24h": "0.06019",
        #         "volCcy24h": "11788.887619",
        #         "vol24h": "167493.829229",
        #         "ts": "1621440583784",
        #         "sodUtc0": "0.07872",
        #         "sodUtc8": "0.07345"
        #     }
        #
        timestamp = self.safe_integer(ticker, 'ts')
        marketId = self.safe_string(ticker, 'instId')
        market = self.safe_market(marketId, market, '-')
        symbol = market['symbol']
        last = self.safe_string(ticker, 'last')
        open = self.safe_string(ticker, 'open24h')
        spot = self.safe_value(market, 'spot', False)
        quoteVolume = self.safe_string(ticker, 'volCurrency24h') if spot else None
        baseVolume = self.safe_string(ticker, 'vol24h')
        high = self.safe_string(ticker, 'high24h')
        low = self.safe_string(ticker, 'low24h')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': high,
            'low': low,
            'bid': self.safe_string(ticker, 'bidPrice'),
            'bidVolume': self.safe_string(ticker, 'bidSize'),
            'ask': self.safe_string(ticker, 'askPrice'),
            'askVolume': self.safe_string(ticker, 'askSize'),
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }, market)

    async def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the okx api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        market = self.market(symbol)
        response = await self.v1PublicGetMarketTickers()
        data = self.safe_value(response, 'data', [])
        for i in range(0, len(data)):
            if data[i]['instId'] == market['id']:
                return self.parse_ticker(data[i], market)

    async def fetch_tickers_by_type(self, type, symbols=None, params={}):
        await self.load_markets()
        response = await self.v1PublicGetMarketTickers()
        tickers = self.safe_value(response, 'data', [])
        return self.parse_tickers(tickers, symbols)

    async def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict params: extra parameters specific to the okx api endpoint
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/#/?id=ticker-structure>`
        """
        await self.load_markets()
        symbols = self.market_symbols(symbols)
        first = self.safe_string(symbols, 0)
        market = None
        if first is not None:
            market = self.market(first)
        type, query = self.handle_market_type_and_params('fetchTickers', market, params)
        return await self.fetch_tickers_by_type(type, symbols, query)

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the woo api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchTrades() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.v1PublicGetMarketTrades(self.extend(request, params))
        #
        # {
        #     success: True,
        #     rows: [
        #         {
        #             symbol: "SPOT_BTC_USDT",
        #             side: "SELL",
        #             executed_price: 46222.35,
        #             executed_quantity: 0.0012,
        #             executed_timestamp: "1641241162.329"
        #         },
        #         {
        #             symbol: "SPOT_BTC_USDT",
        #             side: "SELL",
        #             executed_price: 46222.35,
        #             executed_quantity: 0.0012,
        #             executed_timestamp: "1641241162.329"
        #         },
        #         {
        #             symbol: "SPOT_BTC_USDT",
        #             side: "BUY",
        #             executed_price: 46224.32,
        #             executed_quantity: 0.00039,
        #             executed_timestamp: "1641241162.287"
        #         },
        #         ...
        #      ]
        # }
        #
        resultResponse = self.safe_value(response, 'rows', {})
        return self.parse_trades(resultResponse, market, since, limit)

    def parse_trade(self, trade, market=None):
        #
        # public fetchTrades
        #
        #     {
        #         "instId": "ETH-BTC",
        #         "side": "sell",
        #         "sz": "0.119501",
        #         "px": "0.07065",
        #         "tradeId": "15826757",
        #         "ts": "1621446178316"
        #     }
        #
        # private fetchMyTrades
        #
        #     {
        #         "side": "buy",
        #         "fillSz": "0.007533",
        #         "fillPx": "2654.98",
        #         "fee": "-0.000007533",
        #         "ordId": "317321390244397056",
        #         "instType": "SPOT",
        #         "instId": "ETH-USDT",
        #         "clOrdId": "",
        #         "posSide": "net",
        #         "billId": "317321390265368576",
        #         "tag": "0",
        #         "execType": "T",
        #         "tradeId": "107601752",
        #         "feeCcy": "ETH",
        #         "ts": "1621927314985"
        #     }
        #
        id = self.safe_string(trade, 'tradeId')
        marketId = self.safe_string(trade, 'instId')
        market = self.safe_market(marketId, market, '-')
        symbol = market['symbol']
        timestamp = self.safe_integer(trade, 'ts')
        price = self.safe_string_2(trade, 'fillPx', 'price')
        amount = self.safe_string_2(trade, 'fillSz', 'size')
        side = self.safe_string(trade, 'side')
        orderId = self.safe_string(trade, 'ordId')
        feeCostString = self.safe_string(trade, 'fee')
        fee = None
        if feeCostString is not None:
            feeCostSigned = Precise.string_neg(feeCostString)
            feeCurrencyId = self.safe_string(trade, 'feeCurrency')
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            if feeCurrencyCode is None:
                feeCurrencyCode = 'USDT'
            fee = {
                'cost': feeCostSigned,
                'currency': feeCurrencyCode,
            }
        takerOrMaker = self.safe_string(trade, 'execType')
        if takerOrMaker == 'T':
            takerOrMaker = 'taker'
        elif takerOrMaker == 'M':
            takerOrMaker = 'maker'
        return self.safe_trade({
            'info': self.deep_extend(trade, {'symbol': marketId}),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': orderId,
            'type': None,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': None,
            'fee': fee,
        }, market)

    def parse_token_and_fee_temp(self, item, feeTokenKey, feeAmountKey):
        feeCost = self.safe_string(item, feeAmountKey)
        fee = None
        if feeCost is not None:
            feeCurrencyId = self.safe_string(item, feeTokenKey)
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            fee = {
                'cost': feeCost,
                'currency': feeCurrencyCode,
            }
        return fee

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        # TEALSTREET
        reduceOnly = self.safe_value_2(params, 'reduceOnly', 'close')
        timeInForces = {
            'GTC': 'GTC',
            'PO': 'post_only',  # good till crossing
            'IOC': 'ioc',
            'FOK': 'fok',
        }
        orderTypes = {
            'market': 'market',
            'limit': 'limit',
            'stop': 'conditional',
            'stoplimit': 'trigger',
            'stopLimit': 'trigger',
            'PO': 'post_only',
            'FOK': 'fok',
            'IOC': 'ioc',
            'optimal_limit_ioc': 'optimal_limit_ioc',
        }
        timeInForce = self.safe_string(timeInForces, params['timeInForce'], self.capitalize(params['timeInForce']))
        orderType = self.safe_string(orderTypes, type, self.capitalize(type))
        if timeInForce and orderType != 'conditional' and orderType != 'trigger':
            if timeInForce == 'post_only' or timeInForce == 'fok' or timeInForce == 'ioc':
                orderType = timeInForce
        closeOnTrigger = self.safe_value(params, 'closeOnTrigger', False)
        stopPrice = None
        if orderType == 'conditional' or orderType == 'trigger':
            stopPrice = self.safe_number(params, 'stopPrice')
            if closeOnTrigger:
                reduceOnly = True
            params = self.omit(params, ['reduceOnly'])
        side = side.lower()
        posSide = None
        if (side == 'buy' and reduceOnly) or (side == 'sell' and not reduceOnly):
            posSide = 'short'
        else:
            posSide = 'long'
        marginType = self.safe_string(params, 'marginMode', 'cross')
        method = 'v1PrivatePostTradeOrder'
        if type == 'stop' or type == 'stopLimit':
            method = 'v1PrivatePostTradeOrderTpsl'
        request = {
            'instId': market['id'],
            'marginMode': marginType,
            'side': side,
            # posSide is not used by blofin
            'orderType': orderType,
            'reduceOnly': reduceOnly,
        }
        params = self.omit(params, ['clientOrderId'])
        if price is not None:
            request['price'] = self.price_to_precision(symbol, price)
        request['size'] = self.amount_to_precision(symbol, amount)
        if not reduceOnly:
            request = self.omit(request, ['reduceOnly'])
        if orderType == 'conditional' or orderType == 'trigger':
            # unused by blofin right now
            # triggerType = self.safe_string_lower(params, 'trigger', 'mark')
            params = self.omit(params, ['trigger'])
            # if price is not None:
            #     price = -1
            # else:
            #     orderType = 'conditional'
            #     request['orderType'] = orderType
            # }
            basePrice = self.safe_value(params, 'basePrice')
            if not basePrice:
                ticker = self.fetch_ticker(symbol)
                basePrice = ticker['last']
            # tpPrice = self.safe_number(params, 'tpPrice')
            tpPrice = None
            if stopPrice > basePrice:
                tpPrice = stopPrice
            if tpPrice or stopPrice:
                if price is None:
                    request['orderType'] = 'oco'
                    if tpPrice:
                        request['tpTriggerPrice'] = self.price_to_precision(symbol, tpPrice)
                        request['tpOrderPrice'] = self.price_to_precision(symbol, -1)
                    elif stopPrice:
                        request['slTriggerPrice'] = self.price_to_precision(symbol, stopPrice)
                        request['slOrderPrice'] = self.price_to_precision(symbol, -1)
                    # request['price'] = self.price_to_precision(symbol, price)
                    request['reduceOnly'] = 'true'
                else:
                    # self is from our okx code, but I think second case should be swapped
                    if side == 'sell':
                        if stopPrice > basePrice:
                            request['tpTriggerPrice'] = self.price_to_precision(symbol, tpPrice)
                            request['tpOrderPrice'] = self.price_to_precision(symbol, price)
                        else:
                            request['slTriggerPrice'] = self.price_to_precision(symbol, stopPrice)
                            request['slOrderPrice'] = self.price_to_precision(symbol, price)
                    else:
                        if stopPrice < basePrice:
                            request['tpTriggerPrice'] = self.price_to_precision(symbol, tpPrice)
                            request['tpOrderPrice'] = self.price_to_precision(symbol, price)
                        else:
                            request['slTriggerPrice'] = self.price_to_precision(symbol, stopPrice)
                            request['slOrderPrice'] = self.price_to_precision(symbol, price)
                    request['orderType'] = 'conditional'
                    # request['price'] = self.price_to_precision(symbol, -1)
                    # unsupported?
                    # request['triggerPrice']
                    request['reduceOnly'] = 'true'
                request['price'] = -1
            request['positionSide'] = posSide
        tradeMode = self.safe_string(params, 'tradeMode', 'hedged')
        params = []
        if tradeMode:
            params = self.omit(params, ['tradeMode'])
            if tradeMode == 'oneway':
                request = self.omit(request, ['positionSide'])
            # not implement for blofin yet
            # if tradeMode == 'oneway':
            #     request['positionSide'] = 'oneway'
            # else:
            # request = self.omit(request, ['positionSide'])
            # }
        if marginType:
            params = self.omit(params, ['marginType'])
            request['marginMode'] = marginType
        cloid_suffix = 'r0'
        if reduceOnly:
            cloid_suffix = 'r1'
        request['clientOrderId'] = 'tealstreet' + self.uuid16() + cloid_suffix
        response = await getattr(self, method)(self.extend(request, params))
        data = self.safe_value(response, 'data', [])
        first = self.safe_value(data, 0)
        order = self.parse_order(first, market)
        if not order['status']:
            code = self.safe_string(first, 'code')
            if code == '0':
                order['status'] = 'open'
        return self.extend(self.extend(request, params), self.extend(order, {
            'type': type,
            'side': side,
        }))

    async def cancel_order(self, id, symbol=None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the woo api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a symbol argument')
        await self.load_markets()
        type = self.safe_string_lower(params, 'type')
        isStop = type == 'stop' or type == 'stoplimit'
        if isStop:
            return self.cancel_algo_order(id, symbol, params)
        else:
            return self.cancel_regular_order(id, symbol, params)

    async def cancel_algo_order(self, id, symbol=None, params={}):
        request = {}
        request['tpslId'] = id
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request['instId'] = market['id']
        params = self.omit(params, ['type'])
        request['clientOrderId'] = ''
        response = await self.v1PrivatePostTradeCancelTpsl([self.extend(request, params)])
        #
        # {success: True, status: 'CANCEL_SENT'}
        #
        extendParams = {'symbol': symbol}
        extendParams['id'] = id
        return self.extend(self.parse_order(response), extendParams)

    async def cancel_regular_order(self, id, symbol=None, params={}):
        request = {}
        clientOrderIdUnified = self.safe_string_2(params, 'clOrdID', 'clientOrderId')
        clientOrderIdExchangeSpecific = self.safe_string_2(params, 'clientOrderId', clientOrderIdUnified)
        isByClientOrder = clientOrderIdExchangeSpecific is not None
        if isByClientOrder:
            request['clientOrderId'] = clientOrderIdExchangeSpecific
            params = self.omit(params, ['clOrdID', 'clientOrderId', 'client_order_id'])
        else:
            request['orderId'] = id
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request['instId'] = market['id']
        response = await self.v1PrivatePostTradeCancelOrder(self.extend(request, params))
        #
        # {success: True, status: 'CANCEL_SENT'}
        #
        extendParams = {'symbol': symbol}
        if isByClientOrder:
            extendParams['clientOrderId'] = clientOrderIdExchangeSpecific
        else:
            extendParams['instId'] = id
        return self.extend(self.parse_order(response), extendParams)

    async def cancel_all_orders(self, symbol=None, params={}):
        """
        cancel all open orders in a market
        :param str|None symbol: unified market symbol
        :param dict params: extra parameters specific to the woo api endpoint
        :returns dict: an list of `order structures <https://docs.ccxt.com/#/?id=order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' canelOrders() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = await self.v1PrivateDeleteOrders(self.extend(request, params))
        await self.v3PrivateDeleteAlgoOrdersPending(self.extend(request, params))
        #
        #     {
        #         "success":true,
        #         "status":"CANCEL_ALL_SENT"
        #     }
        #
        return response

    async def fetch_order(self, id, symbol=None, params={}):
        """
        fetches information on an order made by the user
        :param str|None symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the woo api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/#/?id=order-structure>`
        """
        await self.load_markets()
        market = self.market(symbol) if (symbol is not None) else None
        request = {}
        clientOrderId = self.safe_string_2(params, 'clOrdID', 'clientOrderId')
        chosenSpotMethod = None
        type = self.safe_string(params, 'type')
        isStop = type == 'stop' or type == 'stoplimit'
        if isStop:
            chosenSpotMethod = 'v3PrivateDeleteAlgoOrderOid'
        elif clientOrderId:
            chosenSpotMethod = 'v1PrivateGetClientOrderClientOrderId'
            request['client_order_id'] = clientOrderId
        else:
            chosenSpotMethod = 'v1PrivateGetOrderOid'
            request['oid'] = id
        response = await getattr(self, chosenSpotMethod)(self.extend(request, params))
        #
        # {
        #     success: True,
        #     symbol: 'SPOT_WOO_USDT',
        #     status: 'FILLED',  # FILLED, NEW
        #     side: 'BUY',
        #     created_time: '1641480933.000',
        #     order_id: '87541111',
        #     order_tag: 'default',
        #     price: '1',
        #     type: 'LIMIT',
        #     quantity: '12',
        #     amount: null,
        #     visible: '12',
        #     executed: '12',  # or any partial amount
        #     total_fee: '0.0024',
        #     fee_asset: 'WOO',
        #     client_order_id: null,
        #     average_executed_price: '1',
        #     Transactions: [
        #       {
        #         id: '99111647',
        #         symbol: 'SPOT_WOO_USDT',
        #         fee: '0.0024',
        #         side: 'BUY',
        #         executed_timestamp: '1641482113.084',
        #         order_id: '87541111',
        #         executed_price: '1',
        #         executed_quantity: '12',
        #         fee_asset: 'WOO',
        #         is_maker: '1'
        #       }
        #     ]
        # }
        #
        return self.parse_order(response, market)

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        raise NotSupported(self.id + ' fetchOrders() is not supported yet')

    def parse_order(self, order, market=None):
        #
        # createOrder
        #
        #     {
        #         "clOrdId": "oktswap6",
        #         "ordId": "312269865356374016",
        #         "tag": "",
        #         "sCode": "0",
        #         "sMsg": ""
        #     }
        #
        # Spot and Swap fetchOrder, fetchOpenOrders
        #
        #     {
        #         "accFillSz": "0",
        #         "avgPx": "",
        #         "cTime": "1621910749815",
        #         "category": "normal",
        #         "ccy": "",
        #         "clOrdId": "",
        #         "fee": "0",
        #         "feeCcy": "ETH",
        #         "fillPx": "",
        #         "fillSz": "0",
        #         "fillTime": "",
        #         "instId": "ETH-USDT",
        #         "instType": "SPOT",
        #         "lever": "",
        #         "ordId": "317251910906576896",
        #         "ordType": "limit",
        #         "pnl": "0",
        #         "posSide": "net",
        #         "px": "2000",
        #         "rebate": "0",
        #         "rebateCcy": "USDT",
        #         "side": "buy",
        #         "slOrdPx": "",
        #         "slTriggerPx": "",
        #         "state": "live",
        #         "sz": "0.001",
        #         "tag": "",
        #         "tdMode": "cash",
        #         "tpOrdPx": "",
        #         "tpTriggerPx": "",
        #         "tradeId": "",
        #         "uTime": "1621910749815"
        #     }
        #
        # Algo Order fetchOpenOrders, fetchCanceledOrders, fetchClosedOrders
        #
        #     {
        #         "activePx": "",
        #         "activePxType": "",
        #         "actualPx": "",
        #         "actualSide": "buy",
        #         "actualSz": "0",
        #         "algoId": "431375349042380800",
        #         "cTime": "1649119897778",
        #         "callbackRatio": "",
        #         "callbackSpread": "",
        #         "ccy": "",
        #         "ctVal": "0.01",
        #         "instId": "BTC-USDT-SWAP",
        #         "instType": "SWAP",
        #         "last": "46538.9",
        #         "lever": "125",
        #         "moveTriggerPx": "",
        #         "notionalUsd": "467.059",
        #         "ordId": "",
        #         "ordPx": "50000",
        #         "ordType": "trigger",
        #         "posSide": "long",
        #         "pxLimit": "",
        #         "pxSpread": "",
        #         "pxVar": "",
        #         "side": "buy",
        #         "slOrdPx": "",
        #         "slTriggerPx": "",
        #         "slTriggerPxType": "",
        #         "state": "live",
        #         "sz": "1",
        #         "szLimit": "",
        #         "tag": "",
        #         "tdMode": "isolated",
        #         "tgtCcy": "",
        #         "timeInterval": "",
        #         "tpOrdPx": "",
        #         "tpTriggerPx": "",
        #         "tpTriggerPxType": "",
        #         "triggerPx": "50000",
        #         "triggerPxType": "last",
        #         "triggerTime": "",
        #         "uly": "BTC-USDT"
        #     }
        #
        id = self.safe_string_2(order, 'tpslId', 'orderId')
        timestamp = self.safe_integer(order, 'createTime')
        lastTradeTimestamp = self.safe_integer(order, 'updateTime')
        side = self.safe_string(order, 'side')
        type = self.safe_string(order, 'orderType')
        postOnly = None
        timeInForce = None
        if type == 'post_only':
            postOnly = True
            type = 'limit'
        elif type == 'fok':
            timeInForce = 'FOK'
            type = 'limit'
        elif type == 'ioc':
            timeInForce = 'IOC'
            type = 'limit'
        elif type == 'conditional':
            type = 'stop'
        elif type == 'trigger':
            type = 'stoplimit'
        marketId = self.safe_string(order, 'instId')
        market = self.safe_market(marketId, market)
        symbol = marketId
        filled = self.safe_string(order, 'filledSize')
        price = self.safe_number_2(order, 'px', 'price')
        average = self.safe_string(order, 'averagePrice')
        status = self.parse_order_status(self.safe_string(order, 'state'))
        feeCostString = self.safe_string(order, 'fee')
        amount = None
        # cost = None
        # spot market buy: "sz" can refer either to base currency units or to quote currency units
        # see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
        # defaultTgtCcy = self.safe_string(self.options, 'tgtCcy', 'base_ccy')
        # tgtCcy = self.safe_string(order, 'tgtCcy', defaultTgtCcy)
        # instType = self.safe_string(order, 'instType')
        # "sz" refers to the trade currency amount
        amount = self.safe_string(order, 'size')
        fee = None
        if feeCostString is not None:
            feeCostSigned = Precise.string_neg(feeCostString)
            feeCurrencyId = 'USDT'
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            fee = {
                'cost': self.parse_number(feeCostSigned),
                'currency': feeCurrencyCode,
            }
        clientOrderId = self.safe_string(order, 'clientOrderId')
        if (clientOrderId is not None) and (len(clientOrderId) < 1):
            clientOrderId = None  # fix empty clientOrderId string
        stopLossPrice = self.safe_number_2(order, 'slTriggerPrice', 'slOrderPrice')
        takeProfitPrice = self.safe_number_2(order, 'tpTriggerPrice', 'tpOrderPrice')
        stopLossOrderPrice = self.safe_number(order, 'slOrderPrice')
        takeProfitOrderPrice = self.safe_number(order, 'tpOrderPrice')
        triggerPrice = None
        stopPrice = None
        if stopLossPrice:
            if stopLossOrderPrice == -1:
                type = 'stop'
                stopPrice = self.safe_number_2(order, 'tpTriggerPrice', 'slTriggerPrice')
                triggerPrice = stopPrice
            else:
                type = 'stoplimit'
                stopPrice = self.safe_number_2(order, 'tpOrderPrice', 'slOrderPrice')
                price = self.safe_number_2(order, 'tpTriggerPrice', 'slTriggerPrice')
        elif takeProfitPrice:
            if takeProfitOrderPrice == -1:
                type = 'stop'
                stopPrice = self.safe_number_2(order, 'tpTriggerPrice', 'slTriggerPrice')
                triggerPrice = stopPrice
            else:
                type = 'stoplimit'
                stopPrice = self.safe_number_2(order, 'tpOrderPrice', 'slOrderPrice')
                price = self.safe_number_2(order, 'tpTriggerPrice', 'slTriggerPrice')
        # stopPrice = self.safe_number_n(order, ['price', 'stopPrice', 'slTriggerPrice, tpTriggerPrice'])
        reduceOnlyRaw = self.safe_string(order, 'reduceOnly')
        reduceOnly = False
        if reduceOnlyRaw:
            reduceOnly = (reduceOnlyRaw == 'true')
        return self.safe_order({
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': lastTradeTimestamp,
            'symbol': symbol,
            'type': type,
            'timeInForce': timeInForce,
            'postOnly': postOnly,
            'side': side,
            'price': price,
            'stopLossPrice': stopLossPrice,
            'takeProfitPrice': takeProfitPrice,
            'stopPrice': stopPrice,
            'triggerPrice': triggerPrice,
            'average': average,
            'cost': None,
            'amount': amount,
            'filled': filled,
            'remaining': None,
            'status': status,
            'fee': fee,
            'trades': None,
            'reduceOnly': reduceOnly,
            'close': reduceOnly,
            'reduce': reduceOnly,
            'trigger': 'last',
        }, market)

    def parse_order_status(self, status):
        statuses = {
            'canceled': 'canceled',
            'order_failed': 'canceled',
            'live': 'open',
            'partially_filled': 'open',
            'filled': 'closed',
            'effective': 'closed',
        }
        return self.safe_string(statuses, status, status)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {
            # 'instType': 'SPOT',  # SPOT, MARGIN, SWAP, FUTURES, OPTION
            # 'uly': currency['id'],
            # 'instId': market['id'],
            # 'ordType': 'limit',  # market, limit, post_only, fok, ioc, comma-separated, stop orders: conditional, oco, trigger, move_order_stop, iceberg, or twap
            # 'state': 'live',  # live, partially_filled
            # 'after': orderId,
            # 'before': orderId,
            # 'limit': limit,  # default 100, max 100
            'limit': 100,
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['instId'] = market['id']
        if limit is not None:
            request['limit'] = limit  # default 100, max 100
        query = self.omit(params, ['method', 'stop'])
        response = await self.v1PrivateGetTradeOrdersPending(self.extend(request, query))
        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market, since, limit)

    async def fetch_open_stop_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {
            # 'instType': 'SPOT',  # SPOT, MARGIN, SWAP, FUTURES, OPTION
            # 'uly': currency['id'],
            # 'instId': market['id'],
            # 'ordType': 'limit',  # market, limit, post_only, fok, ioc, comma-separated, stop orders: conditional, oco, trigger, move_order_stop, iceberg, or twap
            # 'state': 'live',  # live, partially_filled
            # 'after': orderId,
            # 'before': orderId,
            # 'limit': limit,  # default 100, max 100
            'limit': 100,
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['instId'] = market['id']
        if limit is not None:
            request['limit'] = limit  # default 100, max 100
        query = self.omit(params, ['method', 'stop'])
        response = await self.v1PrivateGetTradeOrdersTpslPending(self.extend(request, query))
        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market, since, limit)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param dict params: extra parameters specific to the woo api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/#/?id=order-book-structure>` indexed by market symbols
        """
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            limit = min(limit, 1000)
            request['max_level'] = limit
        response = await self.v1PrivateGetOrderbookSymbol(self.extend(request, params))
        #
        # {
        #   success: True,
        #   timestamp: '1641562961192',
        #   asks: [
        #     {price: '0.921', quantity: '76.01'},
        #     {price: '0.933', quantity: '477.10'},
        #     ...
        #   ],
        #   bids: [
        #     {price: '0.940', quantity: '13502.47'},
        #     {price: '0.932', quantity: '43.91'},
        #     ...
        #   ]
        # }
        #
        timestamp = self.safe_integer(response, 'timestamp')
        return self.parse_order_book(response, symbol, timestamp, 'bids', 'asks', 'price', 'quantity')

    def parse_ohlcv(self, ohlcv, market=None):
        #
        #     [
        #         "1678928760000",  # timestamp
        #         "24341.4",  # open
        #         "24344",  # high
        #         "24313.2",  # low
        #         "24323",  # close
        #         "628",  # contract volume
        #         "2.5819",  # base volume
        #         "62800",  # quote volume
        #         "0"  # candlestick state
        #     ]
        #
        return [
            self.safe_integer(ohlcv, 0),
            self.safe_number(ohlcv, 1),
            self.safe_number(ohlcv, 2),
            self.safe_number(ohlcv, 3),
            self.safe_number(ohlcv, 4),
            self.safe_number(ohlcv, 7),
        ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        params = self.omit(params, 'price')
        options = self.safe_value(self.options, 'fetchOHLCV', {})
        timezone = self.safe_string(options, 'timezone', 'UTC')
        if limit is None:
            limit = 100
        duration = self.parse_timeframe(timeframe)
        bar = self.safe_string(self.timeframes, timeframe, timeframe)
        if (timezone == 'UTC') and (duration >= 21600):  # if utc and timeframe >= 6h
            bar += timezone.lower()
        request = {
            'instId': market['id'],
            'bar': bar,
            'limit': limit,
        }
        if since is not None:
            durationInMilliseconds = duration * 1000
            startTime = max(since - 1, 0)
            request['before'] = startTime
            request['after'] = self.sum(startTime, durationInMilliseconds * limit)
        until = self.safe_integer(params, 'until')
        if until is not None:
            request['after'] = until
            params = self.omit(params, 'until')
        params = self.omit(params, 'type')
        response = await self.v1PublicGetMarketCandles(self.extend(request, params))
        #
        #     {
        #         "code": "0",
        #         "msg": "",
        #         "data": [
        #             ["1678928760000","24341.4","24344","24313.2","24323","628","2.5819","62800","0"],
        #             ["1678928700000","24324.1","24347.6","24321.7","24341.4","2565","10.5401","256500","1"],
        #             ["1678928640000","24300.2","24324.1","24288","24324.1","3304","13.5937","330400","1"],
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_ohlcvs(data, market, timeframe, since, limit)

    async def fetch_order_trades(self, id, symbol=None, since=None, limit=None, params={}):
        """
        fetch all the trades made from a single order
        :param str id: order id
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades to retrieve
        :param dict params: extra parameters specific to the woo api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        await self.load_markets()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request = {
            'oid': id,
        }
        response = await self.v1PrivateGetOrderOidTrades(self.extend(request, params))
        # {
        #     success: True,
        #     rows: [
        #       {
        #         id: '99111647',
        #         symbol: 'SPOT_WOO_USDT',
        #         fee: '0.0024',
        #         side: 'BUY',
        #         executed_timestamp: '1641482113.084',
        #         order_id: '87541111',
        #         order_tag: 'default',
        #         executed_price: '1',
        #         executed_quantity: '12',
        #         fee_asset: 'WOO',
        #         is_maker: '1'
        #       }
        #     ]
        # }
        trades = self.safe_value(response, 'rows', [])
        return self.parse_trades(trades, market, since, limit, params)

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all trades made by the user
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades structures to retrieve
        :param dict params: extra parameters specific to the woo api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/#/?id=trade-structure>`
        """
        await self.load_markets()
        request = {}
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['start_t'] = since
        response = await self.v1PrivateGetClientTrades(self.extend(request, params))
        # {
        #     "success": True,
        #     "meta": {
        #         "records_per_page": 25,
        #         "current_page": 1
        #     },
        #     "rows": [
        #         {
        #             "id": 5,
        #             "symbol": "SPOT_BTC_USDT",
        #             "order_id": 211,
        #             "order_tag": "default",
        #             "executed_price": 10892.84,
        #             "executed_quantity": 0.002,
        #             "is_maker": 0,
        #             "side": "SELL",
        #             "fee": 0,
        #             "fee_asset": "USDT",
        #             "executed_timestamp": "1566264290.250"
        #         },
        #         ...
        #     ]
        # }
        trades = self.safe_value(response, 'rows', [])
        return self.parse_trades(trades, market, since, limit, params)

    async def fetch_accounts(self, params={}):
        """
        fetch all the accounts associated with a profile
        :param dict params: extra parameters specific to the woo api endpoint
        :returns dict: a dictionary of `account structures <https://docs.ccxt.com/#/?id=account-structure>` indexed by the account type
        """
        response = await self.v1PrivateGetSubAccountAssets(params)
        #
        #     {
        #         rows: [{
        #                 application_id: '13e4fc34-e2ff-4cb7-b1e4-4c22fee7d365',
        #                 account: 'Main',
        #                 usdt_balance: '4.0'
        #             },
        #             {
        #                 application_id: '432952aa-a401-4e26-aff6-972920aebba3',
        #                 account: 'subaccount',
        #                 usdt_balance: '1.0'
        #             }
        #         ],
        #         success: True
        #     }
        #
        rows = self.safe_value(response, 'rows', [])
        return self.parse_accounts(rows, params)

    def parse_account(self, account):
        #
        #     {
        #         application_id: '336952aa-a401-4e26-aff6-972920aebba3',
        #         account: 'subaccount',
        #         usdt_balance: '1.0',
        #     }
        #
        accountId = self.safe_string(account, 'account')
        return {
            'info': account,
            'id': self.safe_string(account, 'application_id'),
            'name': accountId,
            'code': None,
            'type': accountId == 'main' if 'Main' else 'subaccount',
        }

    async def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        see https://docs.woo.org/#get-current-holding-get-balance-new
        :param dict params: extra parameters specific to the woo api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        await self.load_markets()
        response = await self.v1PrivateGetAssetBalances({
            'accountType': 'futures',
        })
        #
        #     {
        #         "success": True,
        #         "data": {
        #             "holding": [
        #                 {
        #                     "token": "0_token",
        #                     "holding": 1,
        #                     "frozen": 0,
        #                     "staked": 0,
        #                     "unbonding": 0,
        #                     "vault": 0,
        #                     "interest": 0,
        #                     "pendingShortQty": 0,
        #                     "pendingLongQty": 0,
        #                     "availableBalance": 0,
        #                     "updatedTime": 312321.121
        #                 }
        #             ]
        #         },
        #         "timestamp": 1673323746259
        #     }
        #
        return self.parse_balance(response)

    def parse_balance(self, response):
        # {
        #     "arg":{
        #        "channel":"account"
        #     },
        #     "data":{
        #        "ts":"1704393619013",
        #        "totalEquity":"256.178577844908301002183444330",
        #        "isolatedEquity":"0.000000",
        #        "details":[
        #           {
        #              "currency":"USDT",
        #              "equity":"255.921376861162832355666",
        #              "available":"201.107018742055904790666",
        #              "balance":"198.028033493752832355",
        #              "ts":"1704393619013",
        #              "isolatedEquity":"0",
        #              "equityUsd":"256.178577844908301002183444330",
        #              "availableEquity":"201.107018742055904790666",
        #              "frozen":"0.26160000000000003",
        #              "orderFrozen":"0.26160000000000003",
        #              "unrealizedPnl":"57.893343367410000000666",
        #              "isolatedUnrealizedPnl":"0"
        #           }
        #        ]
        #     }
        #  }
        result = {
            'info': response,
        }
        balances = self.safe_value(response, 'data', [])
        for i in range(0, len(balances)):
            balance = balances[i]
            code = self.safe_currency_code(self.safe_string(balance, 'currency'))
            account = self.account()
            account['total'] = self.safe_string(balance, 'balance')
            account['free'] = Precise.string_add(self.safe_string(balance, 'available'), self.safe_string(balance, 'bonus'))
            result[code] = account
        return self.safe_balance(result)

    def get_currency_from_chaincode(self, networkizedCode, currency):
        if currency is not None:
            return currency
        else:
            parts = networkizedCode.split('_')
            partsLength = len(parts)
            firstPart = self.safe_string(parts, 0)
            currencyId = self.safe_string(parts, 1, firstPart)
            if partsLength > 2:
                currencyId += '_' + self.safe_string(parts, 2)
            currency = self.safe_currency(currencyId)
        return currency

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        isArray = isinstance(params, list)
        request = '/api/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        url = self.implode_hostname(self.urls['api']['rest']) + request
        # type = self.getPathAuthenticationType(path)
        if api[1] == 'public':
            if query:
                url += '?' + self.urlencode(query)
        elif api[1] == 'private':
            self.check_required_credentials()
            timestamp = self.number_to_string(self.milliseconds())
            nonce = self.uuid()
            headers = {
                'ACCESS-KEY': self.apiKey,
                'ACCESS-PASSPHRASE': self.password,
                'ACCESS-TIMESTAMP': timestamp,
                'ACCESS-NONCE': nonce,
                # 'OK-FROM': '',
                # 'OK-TO': '',
                # 'OK-LIMIT': '',
            }
            auth = request + method + timestamp + nonce
            if method == 'GET':
                if query:
                    urlencodedQuery = '?' + self.urlencode(query)
                    url += urlencodedQuery
                    auth = request + urlencodedQuery + method + timestamp + nonce
            else:
                if isArray or query:
                    body = self.json(query)
                    auth += body
                headers['Content-Type'] = 'application/json'
            signature = self.binary_to_base64(self.encode(self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'hex')))
            headers['ACCESS-SIGN'] = signature
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def parse_income(self, income, market=None):
        #
        #     {
        #         "id":666666,
        #         "symbol":"PERP_BTC_USDT",
        #         "funding_rate":0.00001198,
        #         "mark_price":28941.04000000,
        #         "funding_fee":0.00069343,
        #         "payment_type":"Pay",
        #         "status":"COMPLETED",
        #         "created_time":"1653616000.666",
        #         "updated_time":"1653616000.605"
        #     }
        #
        marketId = self.safe_string(income, 'symbol')
        symbol = self.safe_symbol(marketId, market)
        amount = self.safe_number(income, 'funding_fee')
        code = self.safe_currency_code('USD')
        id = self.safe_string(income, 'id')
        timestamp = self.safe_timestamp(income, 'updated_time')
        rate = self.safe_number(income, 'funding_rate')
        return {
            'info': income,
            'symbol': symbol,
            'code': code,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'id': id,
            'amount': amount,
            'rate': rate,
        }

    async def fetch_leverage(self, symbol, params={}):
        """
        fetch the set leverage for a market
        see https://www.okx.com/docs-v5/en/#rest-api-account-get-leverage
        :param str symbol: unified market symbol
        :param dict params: extra parameters specific to the okx api endpoint
        :param str params['marginMode']: 'cross' or 'isolated'
        :returns dict: a `leverage structure <https://docs.ccxt.com/#/?id=leverage-structure>`
        """
        await self.load_markets()
        marginMode = None
        marginMode, params = self.handle_margin_mode_and_params('fetchLeverage', params)
        if marginMode is None:
            marginMode = self.safe_string(params, 'marginMode', 'cross')  # cross marginMode
        if (marginMode != 'cross') and (marginMode != 'isolated'):
            raise BadRequest(self.id + ' fetchLeverage() requires a marginMode parameter that must be either cross or isolated')
        market = self.market(symbol)
        request = {
            'instId': market['id'],
            'marginMode': marginMode,
        }
        response = await self.v1PrivateGetAccountLeverageInfo(self.extend(request, params))
        #
        #     {
        #        "code": "0",
        #        "data": [
        #            {
        #                "instId": "BTC-USDT-SWAP",
        #                "lever": "5.00000000",
        #                "mgnMode": "isolated",
        #                "posSide": "net"
        #            }
        #        ],
        #        "msg": ""
        #     }
        #
        return response

    async def set_leverage(self, leverage, symbol=None, params={}):
        await self.load_markets()
        # if (leverage != 1) and (leverage != 2) and (leverage != 3) and (leverage != 4) and (leverage != 5) and (leverage != 10) and (leverage != 15) and (leverage != 20) and (leverage != 50):
        #     raise BadRequest(self.id + ' leverage should be 1, 2, 3, 4, 5, 10, 15, 20 or 50')
        # }
        request = {
            'instId': symbol,
            'leverage': leverage,
            'marginMode': params['marginMode'],
        }
        return await self.v1PrivatePostAccountSetLeverage(self.extend(request, params))

    async def set_margin_mode(self, marginMode, symbol=None, params={}):
        await self.load_markets()
        # if (leverage != 1) and (leverage != 2) and (leverage != 3) and (leverage != 4) and (leverage != 5) and (leverage != 10) and (leverage != 15) and (leverage != 20) and (leverage != 50):
        #     raise BadRequest(self.id + ' leverage should be 1, 2, 3, 4, 5, 10, 15, 20 or 50')
        # }
        request = {
            'instId': symbol,
            'leverage': params['leverage'],
            'marginMode': marginMode,
        }
        return await self.v1PrivatePostAccountSetLeverage(self.extend(request, params))

    async def fetch_positions(self, symbols=None, params={}):
        await self.load_markets()
        request = {
            # 'instType': 'MARGIN',  # optional string, MARGIN, SWAP, FUTURES, OPTION
            # 'instId': market['id'],  # optional string, e.g. 'BTC-USD-190927-5000-C'
            # 'posId': '307173036051017730',  # optional string, Single or multiple position IDs(no more than 20) separated with commas
        }
        if symbols is not None:
            marketIds = []
            for i in range(0, len(symbols)):
                entry = symbols[i]
                market = self.market(entry)
                marketIds.append(market['id'])
            marketIdsLength = len(marketIds)
            if marketIdsLength > 0:
                request['instId'] = ','.join(marketIds)
        response = await self.v1PrivateGetAccountPositions(self.extend(request, params))
        positions = self.safe_value(response, 'data', [])
        result = []
        for i in range(0, len(positions)):
            result.append(self.parse_position(positions[i]))
        return self.filter_by_array(result, 'symbol', symbols, False)

    def parse_position(self, position, market=None):
        #
        #     {
        #       "adl": "3",
        #       "availPos": "1",
        #       "avgPx": "34131.1",
        #       "cTime": "1627227626502",
        #       "ccy": "USDT",
        #       "deltaBS": "",
        #       "deltaPA": "",
        #       "gammaBS": "",
        #       "gammaPA": "",
        #       "imr": "170.66093041794787",
        #       "instId": "BTC-USDT-SWAP",
        #       "instType": "SWAP",
        #       "interest": "0",
        #       "last": "34134.4",
        #       "lever": "2",
        #       "liab": "",
        #       "liabCcy": "",
        #       "liqPx": "12608.959083877446",
        #       "margin": "",
        #       "mgnMode": "cross",
        #       "mgnRatio": "140.49930117599155",
        #       "mmr": "1.3652874433435829",
        #       "notionalUsd": "341.5130010779638",
        #       "optVal": "",
        #       "pos": "1",
        #       "posCcy": "",
        #       "posId": "339552508062380036",
        #       "posSide": "long",
        #       "thetaBS": "",
        #       "thetaPA": "",
        #       "tradeId": "98617799",
        #       "uTime": "1627227626502",
        #       "upl": "0.0108608358957281",
        #       "uplRatio": "0.0000636418743944",
        #       "vegaBS": "",
        #       "vegaPA": ""
        #     }
        #
        marketId = self.safe_string(position, 'instId')
        market = self.safe_market(marketId, market)
        # symbol = market['symbol']
        symbol = marketId
        contractsString = self.safe_string(position, 'positions')
        contracts = None
        if contractsString is not None:
            contracts = self.parse_number(contractsString)
        notionalString = self.safe_string(position, 'notionalUsd')
        notional = self.parse_number(notionalString)
        marginType = self.safe_string(position, 'marginMode')
        initialMarginString = None
        entryPriceString = self.safe_string(position, 'averagePrice')
        unrealizedPnlString = self.safe_string(position, 'unrealizedPnl')
        if marginType == 'cross':
            initialMarginString = self.safe_string(position, 'initialMargin')
        #  else {
        #     # initialMarginString = self.safe_string(position, 'margin')
        # }
        maintenanceMarginString = self.safe_string(position, 'maintenanceMargin')
        maintenanceMargin = self.parse_number(maintenanceMarginString)
        initialMarginPercentage = None
        maintenanceMarginPercentage = None
        if market['inverse']:
            notionalValue = Precise.string_div(
                Precise.string_mul(contractsString, market['contractSize']),
                entryPriceString
            )
            maintenanceMarginPercentage = Precise.string_div(maintenanceMarginString, notionalValue)
            initialMarginPercentage = self.parse_number(
                Precise.string_div(initialMarginString, notionalValue, 4)
            )
        else:
            maintenanceMarginPercentage = Precise.string_div(maintenanceMarginString, notionalString)
            initialMarginPercentage = self.parse_number(
                Precise.string_div(initialMarginString, notionalString, 4)
            )
        rounder = '0.00005'  # round to closest 0.01%
        maintenanceMarginPercentage = self.parse_number(
            Precise.string_div(Precise.string_add(maintenanceMarginPercentage, rounder), '1', 4)
        )
        collateralString = Precise.string_add(initialMarginString, unrealizedPnlString)
        liquidationPrice = self.safe_number(position, 'liquidationPrice')
        percentageString = self.safe_string(position, 'unrealizedPnlRatio')
        percentage = self.parse_number(Precise.string_mul(percentageString, '100'))
        side = self.safe_string(position, 'positionSide')
        if side == 'net':
            side = 'long' if Precise.string_gt(contractsString, '0') else 'short'
        if side == 'short' and Precise.string_gt(contractsString, '0'):
            contracts = contracts * -1
        timestamp = self.safe_integer(position, 'updateTime')
        leverage = self.safe_integer(position, 'leverage')
        marginRatio = self.parse_number(
            Precise.string_div(maintenanceMarginString, collateralString, 4)
        )
        id = symbol + ':' + side + ':' + marginType
        status = 'closed'
        if contractsString != '0':
            status = 'open'
        return {
            'id': id,
            'info': self.deep_extend(position, {'symbol': symbol}),
            'symbol': symbol,
            'notional': notional,
            'marginType': marginType,
            'liquidationPrice': liquidationPrice,
            'entryPrice': self.parse_number(entryPriceString),
            'unrealizedPnl': self.parse_number(unrealizedPnlString),
            'percentage': percentage,
            'contracts': contracts,
            'contractSize': self.parse_number(market['contractSize']),
            'side': side,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'maintenanceMargin': maintenanceMargin,
            'maintenanceMarginPercentage': maintenanceMarginPercentage,
            'collateral': self.parse_number(collateralString),
            'initialMargin': self.parse_number(initialMarginString),
            'initialMarginPercentage': self.parse_number(initialMarginPercentage),
            'leverage': leverage,
            'marginRatio': marginRatio,
            'isolated': marginType != 'cross',
            'status': status,
            'tradeMode': 'oneway',
            # 'info': info,
            # 'id': id,
            # 'symbol': symbol,
            # 'timestamp': timestamp,
            # 'datetime': datetime,
            # 'isolated': isolated,
            # 'hedged': hedged,
            # 'side': side,
            # 'contracts': contracts,
            # 'price': price,
            # 'markPrice': markPrice,
            # 'notional': notional,
            # 'leverage': leverage,
            # 'initialMargin': initialMargin,
            # 'maintenanceMargin': maintenanceMargin,
            # 'initialMarginPercentage': initialMarginPercentage,
            # 'maintenanceMarginPercentage': maintenanceMarginPercentage,
            # 'unrealizedPnl': unrealizedPnl,
            # 'pnl': pnl,
            # 'liquidationPrice': liquidationPrice,
            # 'status': status,
            # 'entryPrice': entryPrice,
            # 'marginRatio': marginRatio,
            # 'collateral': collateral,
            # 'marginType': marginType,
            # 'percentage': percentage,
            # 'maxLeverage': maxLeverage,
            # 'tradeMode': tradeMode,
        }

    async def fetch_account_configuration(self, symbol, params={}):
        await self.load_markets()
        if symbol == 'BTC/USDT:USDT':
            symbol = 'BTC-USDT'
        market = self.market(symbol)
        leverageInfo = await self.fetch_leverage(market['id'])
        leverage = self.safe_integer(leverageInfo, 'leverage')
        accountConfig = {
            'marginMode': 'cross',
            'positionMode': 'oneway',
            'markets': {},
            'leverage': leverage,
        }
        leverageConfigs = accountConfig['markets']
        leverageConfigs[market['symbol']] = {
            'leverage': leverage,
            'buyLeverage': leverage,
            'sellLeverage': leverage,
        }
        return accountConfig

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # fallback to default error handler
        #
        #    {
        #        "code": "1",
        #        "data": [
        #            {
        #                "clOrdId": "",
        #                "ordId": "",
        #                "sCode": "51119",
        #                "sMsg": "Order placement failed due to insufficient balance. ",
        #                "tag": ""
        #            }
        #        ],
        #        "msg": ""
        #    },
        #    {
        #        "code": "58001",
        #        "data": [],
        #        "msg": "Incorrect trade password"
        #    }
        #
        code = self.safe_string(response, 'code')
        if code != '0':
            feedback = self.id + ' ' + body
            data = self.safe_value(response, 'data', [])
            for i in range(0, len(data)):
                error = data[i]
                errorCode = self.safe_string(error, 'sCode')
                message = self.safe_string(error, 'sMsg')
                self.throw_exactly_matched_exception(self.exceptions['exact'], errorCode, feedback)
                self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            self.throw_exactly_matched_exception(self.exceptions['exact'], code, feedback)
            raise ExchangeError(feedback)  # unknown message

    def market(self, symbol):
        symbol = symbol.replace('/', '-')
        # symbol = symbol + ':USDT'
        if self.markets is None:
            raise ExchangeError(self.id + ' markets not loaded')
        if self.markets_by_id is None:
            raise ExchangeError(self.id + ' markets not loaded')
        # TEALSTREET patch for backwards compatability
        # self.market_helper(symbol.split(':')[0])
        foundMarket = self.market_helper(symbol)
        if foundMarket:
            return foundMarket
        marketStem = symbol.split(':')[0]
        marketParts = marketStem.split('/')
        if len(marketParts) == 2:
            foundMarket = self.market_helper(marketParts[0] + '/' + marketParts[1] + ':' + marketParts[1])
        if foundMarket:
            return foundMarket
        foundMarket = self.market_helper(marketStem + ':USDT') or self.market_helper(marketStem + ':BTC') or self.market_helper(marketStem)
        if foundMarket:
            return foundMarket
        # eslint-disable-next-line no-console
        # print(symbol)
        # eslint-disable-next-line no-console
        # print(self.markets)
        raise BadSymbol(self.id + ' does not have market symbol ' + symbol)
